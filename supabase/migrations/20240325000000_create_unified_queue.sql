-- Create unified queue table and triggers  
CREATE TABLE IF NOT EXISTS public.unified_processing_queue ( id BIGSERIAL PRIMARY KEY, queue_type TEXT NOT NULL CHECK (queue_type IN ('webhook', 'media', 'analysis')), data JSONB NOT NULL, status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')), retry_count INTEGER NOT NULL DEFAULT 0, max_retries INTEGER NOT NULL DEFAULT 3, priority INTEGER NOT NULL DEFAULT 1, correlation_id UUID NOT NULL, error_message TEXT, created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), started_at TIMESTAMPTZ, completed_at TIMESTAMPTZ );  
CREATE INDEX IF NOT EXISTS idx_unified_queue_status ON public.unified_processing_queue(status); CREATE INDEX IF NOT EXISTS idx_unified_queue_correlation ON public.unified_processing_queue(correlation_id);  
-- Add correlation_id to messages table if not exists ALTER TABLE public.messages ADD COLUMN IF NOT EXISTS correlation_id UUID;  
-- Create trigger function CREATE OR REPLACE FUNCTION public.fn_queue_message_processing() RETURNS TRIGGER AS $$ BEGIN IF NEW.analyzed_content IS NOT NULL AND NEW.status = 'pending' THEN IF NEW.correlation_id IS NULL THEN NEW.correlation_id := gen_random_uuid(); END IF; INSERT INTO public.unified_processing_queue (queue_type, data, correlation_id) VALUES ('media', jsonb_build_object('message_id', NEW.id, 'media_group_id', NEW.media_group_id, 'analyzed_content', NEW.analyzed_content), NEW.correlation_id); NEW.status := 'processing'; END IF; RETURN NEW; END; $$ LANGUAGE plpgsql;  
-- Create trigger DROP TRIGGER IF EXISTS trg_queue_message_processing ON public.messages; CREATE TRIGGER trg_queue_message_processing BEFORE INSERT OR UPDATE OF analyzed_content, status ON public.messages FOR EACH ROW WHEN (NEW.analyzed_content IS NOT NULL AND NEW.status = 'pending') EXECUTE FUNCTION public.fn_queue_message_processing();  
